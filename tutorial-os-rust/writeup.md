# How to setup the pi3 tutorial and run it ...

Install teh necessary tools 
```bash
rustup component add llvm-tools-preview      
cargo install cargo-binutils
```

Set the path for cargo binary so that make can access it
```bash
export PATH="$HOME/.cargo/bin:$PATH"
```


Install docker
```bash
# install docker
sudo pacman -S docker

# start the docker service
sudo systemctl start docker.service

# create a newuser group for docker // only for arch linux
newgrp docker

# add the current user to that group
sudo usermod -aG docker $USER

# list the permission for dock.sock
ls -l /var/run/docker.sock 

# allow every user to acces thta previleged file
# very high ecurity risk just for local computer and remove when not needed
sudo chmod 666 /var/run/docker.sock 


# make with file
make qemu

```



# Understanding the makefile

```
aarch64-unknown-none-softfloat
```

is whatâ€™s called a **Rust target triple** (technically sometimes a *quadruple*). It tells the Rust compiler **what kind of machine and environment youâ€™re compiling for**. 

---

### 1. `aarch64`

* The **CPU architecture**.
* `aarch64` = 64-bit ARM architecture (ARMv8-A).
* This is what modern ARM processors use (like Raspberry Pi 3/4/5, Apple M1/M2, many phones).

---

### 2. `unknown`

* The **vendor** field.
* Here itâ€™s just `unknown` because there isnâ€™t a specific vendor platform being targeted.
* Example: on Linux you might see `pc` or `apple`, but for bare-metal OS dev we donâ€™t tie to any vendor.

---

### 3. `none`

* The **operating system / environment**.
* `none` means *no operating system*.
* This is used for **bare-metal development**, like writing kernels or firmware that run directly on the hardware without Linux, Windows, or macOS.

---

### 4. `softfloat`

* The **ABI (Application Binary Interface)** / **floating-point handling**.
* `softfloat` means **software floating-point emulation** instead of hardware floating-point instructions.
* Why?

  * Not all ARM cores have a floating-point unit (FPU).
  * Using `softfloat` makes the code more portable because it doesnâ€™t assume hardware floating-point support.

Thereâ€™s also `hardfloat`, which would use actual FPU instructions (faster but only works on CPUs that have an FPU).





QEMU_RELEASE_ARGS = -d in_asm -display none
- Extra runtime arguments passed to QEMU.
- -d in_asm â†’ dump instructions as theyâ€™re executed (debugging aid).
- -display none â†’ disable graphical window (since weâ€™re just testing kernel boot, not graphics).


OBJDUMP_BINARY = aarch64-none-elf-objdump
- The objdump tool (from an ARM cross-compiler toolchain).
- Used to disassemble ELF binaries and inspect machine code.

NM_BINARY = aarch64-none-elf-nm
- nm lists the symbols inside an object file (functions, variables, etc).
- Useful for debugging kernel builds.

READELF_BINARY = aarch64-none-elf-readelf
- readelf inspects ELF headers.
- Lets you check sections, program headers, memory layout of your kernel ELF.

### export in makefile
Make this variable available to all child processes and sub-makes as an environment variable.

ðŸ”¹ Without export:
- LD_SCRIPT_PATH is only a Makefile variable.
- You can use $(LD_SCRIPT_PATH) inside this Makefile, but if you spawn a child process (like a script or another Makefile), it wonâ€™t see it as an environment variable unless you explicitly pass it.

ðŸ”¹ With export:
- It becomes part of the environment.
- Any tools you run (rustc, linker, scripts, etc.) will see LD_SCRIPT_PATH like a normal $LD_SCRIPT_PATH environment variable in the shell.
- Also, if your Makefile calls another Makefile with make -C some/dir, the sub-make will inherit this variable automatically.



### understanding the following command
```bash
# This parses cargo's dep-info file.
# https://doc.rust-lang.org/cargo/guide/build-cache.html#dep-info-files
KERNEL_ELF_DEPS = $(filter-out %: ,$(file < $(KERNEL_ELF).d)) $(KERNEL_MANIFEST) $(LAST_BUILD_CONFIG)
```
1. ss
- When Cargo (or rustc) compiles, it can emit a .d file (dependency info).
This file lists all the source files that the final artifact depends on.
Itâ€™s the same idea as .d files generated by gcc -M for C builds.

kernel.elf.d might looks like this
```bash
kernel.elf: src/main.rs src/lib.rs Cargo.toml target/debug/deps/libcore-...rlib
```

2. `$(file < $(KERNEL_ELF).d)`

- The GNU Make file function with < reads the contents of a file.
- Here, it reads the dependency file: $(KERNEL_ELF).d.
- If KERNEL_ELF = build/kernel.elf, then it reads build/kernel.elf.d.

3. $(filter-out %: , ...)

- filter-out removes words matching a pattern.
- Here the pattern is %: (any filename ending with :).
- That strips out the left-hand side target (kernel.elf:), leaving only the dependency file list:
- src/main.rs src/lib.rs Cargo.toml


4. Adding extra dependencies
... $(KERNEL_MANIFEST) $(LAST_BUILD_CONFIG)


- $(KERNEL_MANIFEST) â†’ usually points to your Cargo.toml (the Rust manifest).

- $(LAST_BUILD_CONFIG) â†’ some file that encodes your last build configuration (ensures rebuilds if config changes).

So even if the .d file missed them, these are explicitly added to the dependency list.